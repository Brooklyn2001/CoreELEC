diff -Naurp linux/drivers/amlogic/amports/vh265.c linux-patch/drivers/amlogic/amports/vh265.c
--- linux/drivers/amlogic/amports/vh265.c	2018-11-30 09:45:44.000000000 +0200
+++ linux-patch/drivers/amlogic/amports/vh265.c	2018-11-30 09:51:02.000000000 +0200
@@ -8349,7 +8349,7 @@ static int amvdec_h265_probe(struct plat
 
 	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) &&
 		(parser_sei_enable & 0x100) == 0)
-		parser_sei_enable = 1;
+		parser_sei_enable = 7;
 	hevc->m_ins_flag = 0;
 	hevc->init_flag = 0;
 	hevc->uninit_list = 0;
@@ -8561,7 +8561,7 @@ static int ammvdec_h265_probe(struct pla
 #endif
 	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) &&
 		(parser_sei_enable & 0x100) == 0)
-		parser_sei_enable = 1;
+		parser_sei_enable = 7;
 	hevc->m_ins_flag = 1;
 	hevc->init_flag = 0;
 	hevc->uninit_list = 0;
diff -Naurp linux/drivers/amlogic/amports/video.c linux-patch/drivers/amlogic/amports/video.c
--- linux/drivers/amlogic/amports/video.c	2018-11-30 09:45:44.000000000 +0200
+++ linux-patch/drivers/amlogic/amports/video.c	2018-11-30 09:51:02.000000000 +0200
@@ -49,7 +49,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/dma-contiguous.h>
 #include <linux/switch.h>
-
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
 
 
 #include "amports_priv.h"
@@ -697,6 +697,9 @@ static u32 ori2_end_y_lines;
 /* wide settings */
 static u32 wide_setting = 1;
 
+/* auto colour depth switching: 0 = on, 1 = off */
+static u32 disable_cdsw = 0;
+
 /* black out policy */
 #if defined(CONFIG_JPEGLOGO)
 static u32 blackout;
@@ -3740,6 +3743,76 @@ static int dolby_vision_need_wait(void)
 		return 1;
 	return 0;
 }
+int bitdepthY, bitdepth;
+char* primaries_str[] = {"unknown", "bt709", "undef", "bt601",
+	"bt470m", "bt470bg", "smpte170m", "smpte240m",
+	"film", "bt2020"};
+char* transfer_str[] = {"unknown", "bt709", "undef", "bt601",
+	"bt470m", "bt470bg", "smpte170m", "smpte240m",
+	"linear", "log100", "log316", "iec61966-2-4",
+	"bt1361e", "iec61966-2-1", "bt2020-10", "bt2020-12",
+	"smpte-st-2084", "smpte-st-428"};
+char* matrix_str[] = {"GBR", "bt709", "undef", "bt601",
+	"fcc", "bt470bg", "smpte170m", "smpte240m",
+	"YCgCo", "bt2020nc", "bt2020c"};
+struct vframe_master_display_colour_s *mdc;
+static void dump_params(struct vframe_s *dispbuf0);
+
+/* report all the info we can get from the stream */
+static void dump_params(struct vframe_s *dispbuf0){
+	if (dispbuf0){
+		struct vframe_s *dispbuf;
+		dispbuf = vf_peek("ppmgr");
+		if (dispbuf){
+		if (dispbuf->type & VIDTYPE_COMPRESS)
+			pr_info(" Frame parameters: Size %dx%d (compressed)\n", dispbuf->compWidth, dispbuf->compHeight);
+		else
+			pr_info(" Frame parameters: Size %dx%d\n", dispbuf->width, dispbuf->height);
+		if ((dispbuf->type & VIDTYPE_TYPEMASK) ==
+				VIDTYPE_INTERLACE_TOP)
+			pr_info(" interlace-top\n");
+		else if ((dispbuf->type & VIDTYPE_TYPEMASK) ==
+				VIDTYPE_INTERLACE_BOTTOM)
+			pr_info(" interlace-bottom\n");
+		else if (dispbuf->type & VIDTYPE_INTERLACE_FIRST)
+			pr_info(" interlace-first\n");
+		else
+			pr_info(" progressive\n");
+		pr_info(" (Full type: 0x%08x)\n", dispbuf->type);
+		bitdepthY = (dispbuf->bitdepth >> BITDEPTH_Y_SHIFT) & 0x3;
+		if (bitdepthY == 0)
+			bitdepth = 8;
+		else if (bitdepthY == 2)
+			bitdepth = 10;
+		else if (bitdepthY == 3)
+			bitdepth = 12; // guessing
+		pr_info(" Bit depth: %d-bit, Colour range: %s\n", bitdepth, ((dispbuf->signal_type >> 25) & 0x1) ? "full" : "limited");
+		if ((dispbuf->signal_type >> 24) & 0x1){
+			pr_info(" Primaries: %s, Transfer function: %s, RGB-YCC: %s\n",
+					primaries_str[(dispbuf->signal_type >> 16) & 0xff],
+					transfer_str[(dispbuf->signal_type >> 8) & 0xff],
+					matrix_str[dispbuf->signal_type & 0xff]);
+		}
+		else
+			pr_info(" No colour data present\n");
+		if (dispbuf->prop.master_display_colour.present_flag){
+			mdc = &(dispbuf->prop.master_display_colour);
+			pr_info(" Master display colours:\nPrimary red 0.%04d,0.%04d, green 0.%04d,0.%04d, blue 0.%04d,0.%04d\nWhite0.%04d,0.%04d, Luminance max/min: %d,0.%03d\n",
+					mdc->primaries[2][0]*2/10,mdc->primaries[2][1]*2/10,
+					mdc->primaries[0][0]*2/10,mdc->primaries[0][1]*2/10,
+					mdc->primaries[1][0]*2/10,mdc->primaries[1][1]*2/10,
+					mdc->white_point[0]*2/10,mdc->white_point[1]*2/10,
+					mdc->luminance[0]/10000,mdc->luminance[1]);
+			//if (mdc->content_light_level.present_flag)
+				pr_info(" Max content luminance: %d, Max average luminance: %d\n",
+						mdc->content_light_level.max_content/10000, mdc->content_light_level.max_pic_average/10000);
+			//else pr_info(" No content light levels\n");
+		}
+		else pr_info(" No master display info\n");
+	}
+	}
+	return;
+}
 
 #ifdef FIQ_VSYNC
 void vsync_fisr(void)
@@ -3765,6 +3838,7 @@ static irqreturn_t vsync_isr(int irq, vo
 #endif
 	struct vframe_s *toggle_vf = NULL;
 	int video1_off_req = 0;
+	struct hdmitx_dev *hdev;
 
 	if (debug_flag & DEBUG_FLAG_VSYNC_DONONE)
 		return IRQ_HANDLED;
@@ -3805,13 +3879,56 @@ static irqreturn_t vsync_isr(int irq, vo
 #endif
 
 	vf = video_vf_peek();
+   	hdev = get_hdmitx_device();
+	enum hdmi_color_depth cur_cd;
+	cur_cd = hdev->para->cd;
 	if ((vf) && ((vf->type & VIDTYPE_NO_VIDEO_ENABLE) == 0)) {
+		int bitdepthY;
+		enum hdmi_color_depth new_cd;
+		bitdepthY = (vf->bitdepth >> BITDEPTH_Y_SHIFT) & 0x3;
+		switch (bitdepthY){
+			case 2:
+				new_cd = COLORDEPTH_30B;
+				break;
+			case 3:
+				new_cd = COLORDEPTH_36B;
+				break;
+			case 0:
+			default:
+				new_cd = COLORDEPTH_24B;
+		}
+		if (new_cd != cur_cd && disable_cdsw != 1){
+			video_property_changed = true;
+			hdev->para->cd = new_cd;
+			pr_info(" Colourdepth changed in stream to %dB in para 0x%08x (%s)\n",(int) hdev->para->cd * 6, hdev->para, hdev->para->name);
+			if (hdev->cur_video_param != NULL){
+				hdev->cur_video_param->color_depth = new_cd;
+				pr_info(" Colourdepth set from stream as %d in cur_param 0x%08x (VIC: %d)\n", hdev->cur_video_param->color_depth,
+						hdev->cur_video_param, hdev->cur_video_param->VIC);
+			}
+		}
 		if ((old_vmode != new_vmode) || (debug_flag == 8)) {
 			debug_flag = 1;
 			video_property_changed = true;
-			pr_info("detect vout mode change!!!!!!!!!!!!\n");
+			pr_info(" detect vout mode change! was %d now %d\n",old_vmode,new_vmode);
 			old_vmode = new_vmode;
 		}
+		if (video_property_changed)
+			dump_params(vf);
+
+	} else if (!vf && cur_cd != COLORDEPTH_24B) {
+		struct vframe_provider_s *vfp = vf_get_provider(RECEIVER_NAME);
+		if (!vfp){
+			pr_info(" Frame provider: none\n");
+			hdev->para->cd = COLORDEPTH_24B; // assume 8-bit if not using hw accel
+			pr_info(" Colourdepth reset to %dB in para 0x%08x (%s)\n",(int) hdev->para->cd * 6, hdev->para, hdev->para->name);
+			if (hdev->cur_video_param != NULL){
+				hdev->cur_video_param->color_depth = COLORDEPTH_24B;
+				pr_info(" Colourdepth reset from stream as %d in cur_param 0x%08x (VIC: %d)\n", hdev->cur_video_param->color_depth,
+						hdev->cur_video_param, hdev->cur_video_param->VIC);
+			}
+			video_property_changed = true;
+		}
 	}
 #ifdef CONFIG_AM_VIDEO_LOG
 	toggle_cnt = 0;
@@ -3902,7 +4019,8 @@ static irqreturn_t vsync_isr(int irq, vo
 		u32 system_time = timestamp_pcrscr_get();
 		video_notify_flag |= VIDEO_NOTIFY_TRICK_WAIT;
 		atomic_set(&trickmode_framedone, 1);
-		int diff = system_time - omx_pts;
+		int diff;
+		diff = system_time - omx_pts;
 		if ((diff - omx_pts_interval_upper) > 0
 			|| (diff - omx_pts_interval_lower) < 0) {
 			timestamp_pcrscr_enable(1);
@@ -6639,15 +6757,15 @@ static u32 yuv2rgb(u32 yuv)
 	r = r - 16;
 	if (r < 0)
 		r = 0;
-		r = r*1164/1000;
+	r = r*1164/1000;
 	g = g - 16;
 	if (g < 0)
 		g = 0;
-		g = g*1164/1000;
+	g = g*1164/1000;
 	b = b - 16;
 	if (b < 0)
 		b = 0;
-		b = b*1164/1000;
+	b = b*1164/1000;
 
 	r = (r <= 0) ? 0 : (r >= 255) ? 255 : r;
 	g = (g <= 0) ? 0 : (g >= 255) ? 255 : g;
@@ -6839,6 +6957,32 @@ static ssize_t video_disable_store(struc
 	return count;
 }
 
+static ssize_t cdsw_disable_show(struct class *cla,
+				  struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", disable_cdsw);
+}
+
+static ssize_t cdsw_disable_store(struct class *cla,
+				   struct class_attribute *attr,
+				   const char *buf, size_t count)
+{
+	size_t r;
+	int val;
+	if (debug_flag)
+		pr_info("%s(%s)\n", __func__, buf);
+	r = sscanf(buf, "%d", &val);
+	if (r != 1)
+		return -EINVAL;
+	if ((val < 0) || (val > 1))
+		return -EINVAL;
+
+    disable_cdsw = val;
+    
+	return count;
+}
+
+
 static ssize_t video_freerun_mode_show(struct class *cla,
 				       struct class_attribute *attr, char *buf)
 {
@@ -7018,20 +7162,93 @@ static ssize_t frame_format_show(struct
 				 struct class_attribute *attr, char *buf)
 {
 	ssize_t ret = 0;
-
-	if (cur_dispbuf) {
-		if ((cur_dispbuf->type & VIDTYPE_TYPEMASK) ==
+	struct vframe_s *dispbuf;
+	struct vframe_provider_s *vfp;
+	int bitdepthY;
+	int vid_format;
+	int vid_range;
+
+	if (cur_dispbuf){
+	   dispbuf = cur_dispbuf;
+	   ret = sprintf(buf, "cur_dispbuf\n");
+	}
+	else{
+		dispbuf = &vf_local;
+		ret = sprintf(buf, "vf_local\n");
+	}
+	vfp = vf_get_provider(RECEIVER_NAME);
+	if (vfp)
+		ret += sprintf(buf + ret,"Frame provider: %s\n", vfp->name);
+	else
+		ret += sprintf(buf + ret,"Frame provider: none\n");
+	if (dispbuf) {
+		if ((dispbuf->type & VIDTYPE_TYPEMASK) ==
 		    VIDTYPE_INTERLACE_TOP)
-			ret = sprintf(buf, "interlace-top\n");
-		else if ((cur_dispbuf->type & VIDTYPE_TYPEMASK) ==
+			ret += sprintf(buf + ret, "interlace-top\n");
+		else if ((dispbuf->type & VIDTYPE_TYPEMASK) ==
 			 VIDTYPE_INTERLACE_BOTTOM)
-			ret = sprintf(buf, "interlace-bottom\n");
+			ret += sprintf(buf + ret, "interlace-bottom\n");
+		else if (dispbuf->type & VIDTYPE_INTERLACE_FIRST)
+			ret += sprintf(buf + ret, "interlace-first\n");
 		else
-			ret = sprintf(buf, "progressive\n");
+			ret += sprintf(buf + ret, "progressive\n");
 
-		if (cur_dispbuf->type & VIDTYPE_COMPRESS)
+		if (dispbuf->type & VIDTYPE_COMPRESS)
 			ret += sprintf(buf + ret, "Compressed\n");
 
+		ret += sprintf(buf + ret, "(Full type: 0x%08x)\n", dispbuf->type);
+
+		ret += sprintf(buf + ret, "Width (compressed) %d (%d)\n", dispbuf->width, dispbuf->compWidth);
+		ret += sprintf(buf + ret, "Height (compressed) %d (%d)\n", dispbuf->height, dispbuf->compHeight);
+
+		bitdepthY = (dispbuf->bitdepth >> BITDEPTH_Y_SHIFT) & 0x3;
+		if (bitdepthY == 0)
+			ret += sprintf(buf + ret, "Bit depth: 8\n");
+		else if (bitdepthY == 2)
+			ret += sprintf(buf + ret, "Bit depth: 10\n");
+
+	   	vid_format = (dispbuf->signal_type >> 26) & 0x7;
+
+		char* vid_format_str[] = {"component", "PAL", "NTSC", "SECAM",
+			"MAC", "unspecified"}; 
+		ret += sprintf(buf + ret, "Video format: %s\n", vid_format_str[vid_format]);
+
+	   	vid_range = (dispbuf->signal_type >> 25) & 0x1;
+
+		if (vid_range)
+			ret += sprintf(buf + ret, "Range: full\n");
+		else
+			ret += sprintf(buf + ret, "Range: limited\n");
+
+		if ((dispbuf->signal_type >> 24) & 0x1){
+			ret += sprintf(buf + ret, "Primaries: %s\n", primaries_str[(dispbuf->signal_type >> 16) & 0xff]);
+			ret += sprintf(buf + ret, "Transfer function: %s\n", transfer_str[(dispbuf->signal_type >> 8) & 0xff]);
+			ret += sprintf(buf + ret, "RGB-YCC: %s\n", matrix_str[dispbuf->signal_type & 0xff]);
+		}
+		else
+			ret+= sprintf(buf + ret, "No colour data present\n");
+
+		if (dispbuf->prop.bbar.bottom == 0 || dispbuf->prop.bbar.right == 0)
+			ret+= sprintf(buf + ret, "No black bar info\n");
+		else {
+			ret+= sprintf(buf + ret, "Black bars top: %d, bottom %d, left %d, right %d\n",
+					dispbuf->prop.bbar.top, dispbuf->prop.bbar.bottom,
+					dispbuf->prop.bbar.left, dispbuf->prop.bbar.right);
+		}
+		if (dispbuf->prop.master_display_colour.present_flag){
+			mdc = &dispbuf->prop.master_display_colour;
+			ret += sprintf(buf + ret, "Master display colours:\nPrimary red: 0.%04d,0.%04d, green: 0.%04d,0.%04d, blue: 0.%04d,0.%04d\nWhite:0.%04d,0.%04d, Luminance max/min: %d,0.%03d\n",
+					mdc->primaries[2][0]*2/10,mdc->primaries[2][1]*2/10,
+					mdc->primaries[0][0]*2/10,mdc->primaries[0][1]*2/10,
+					mdc->primaries[1][0]*2/10,mdc->primaries[1][1]*2/10,
+					mdc->white_point[0]*2/10,mdc->white_point[1]*2/10,
+					mdc->luminance[0]/1000,mdc->luminance[1]);
+			if (mdc->content_light_level.present_flag)
+				ret += sprintf(buf + ret,"Max content luminance: %d\nMax average luminance: %d\n",
+						mdc->content_light_level.max_content/1000, mdc->content_light_level.max_pic_average/1000);
+			else ret += sprintf(buf + ret,"No content light levels\n");
+		}
+		else ret += sprintf(buf + ret,"No master display info\n");
 		return ret;
 	}
 
@@ -7076,12 +7293,12 @@ static ssize_t frame_rate_show(struct cl
 	if (vinfo->sync_duration_den > 0) {
 		ret =
 		    sprintf(buf,
-		"VF.fps=%d.%02d panel fps %d, dur/is: %d,v/s=%d.%02d,inc=%d\n",
+		"VF.fps=%d.%02d panel fps %d, dur/is: %d,v/s=%d.%02d,inc=%d\nVideo mode %d\n",
 				rate / 100, rate % 100,
 				vinfo->sync_duration_num /
 				vinfo->sync_duration_den,
 				time, vsync_rate / 100, vsync_rate % 100,
-				vsync_pts_inc);
+				vsync_pts_inc,vinfo->mode);
 	}
 	if ((debugflags & DEBUG_FLAG_CALC_PTS_INC) && time > HZ * 10
 	    && vsync_rate > 0) {
@@ -7513,6 +7730,10 @@ static struct class_attribute amvideo_cl
 	       S_IRUGO | S_IWUSR | S_IWGRP,
 	       video_disable_show,
 	       video_disable_store),
+	__ATTR(disable_cdsw,
+	       S_IRUGO | S_IWUSR | S_IWGRP,
+	       cdsw_disable_show,
+	       cdsw_disable_store),
 	__ATTR(zoom,
 	       S_IRUGO | S_IWUSR | S_IWGRP,
 	       video_zoom_show,
diff -Naurp linux/drivers/amlogic/amvecm/amcsc.c linux-patch/drivers/amlogic/amvecm/amcsc.c
--- linux/drivers/amlogic/amvecm/amcsc.c	2018-11-30 09:45:45.000000000 +0200
+++ linux-patch/drivers/amlogic/amvecm/amcsc.c	2018-11-30 09:51:02.000000000 +0200
@@ -3560,14 +3560,18 @@ static void bypass_hdr_process(
 				CSC_OFF);
 
 			/* osd matrix RGB709 to YUV709 limit/full */
-			if (range_control)
+			if (signal_range == 1){
 				set_vpp_matrix(VPP_MATRIX_OSD,
 					RGB709_to_YUV709_coeff,
 					CSC_ON);	/* use full range */
-			else
+				pr_info("Full range RGB-YUV");
+			}
+			else {
 				set_vpp_matrix(VPP_MATRIX_OSD,
 					RGB709_to_YUV709l_coeff,
 					CSC_ON);	/* use limit range */
+				pr_info("Limited range RGB-YUV");
+			}
 		}
 
 		/************** VIDEO **************/
@@ -3585,20 +3589,14 @@ static void bypass_hdr_process(
 					/* limit->full range */
 				else
 					set_vpp_matrix(VPP_MATRIX_VD1,
-						bypass_coeff,
-						CSC_OFF);
+						YUV709f_to_YUV709l_coeff,
+						CSC_ON);
 					/* full->full range */
 			} else {
-				if (signal_range == 0) /* limit range */
 					set_vpp_matrix(VPP_MATRIX_VD1,
 						bypass_coeff,
 						CSC_OFF);
 					/* limit->limit range */
-				else
-					set_vpp_matrix(VPP_MATRIX_VD1,
-						YUV709f_to_YUV709l_coeff,
-						CSC_ON);
-					/* full->limit range */
 			}
 		}
 
diff -Naurp linux/drivers/amlogic/display/osd/osd_fb.c linux-patch/drivers/amlogic/display/osd/osd_fb.c
--- linux/drivers/amlogic/display/osd/osd_fb.c	2018-06-27 06:13:58.000000000 +0300
+++ linux-patch/drivers/amlogic/display/osd/osd_fb.c	2018-11-30 09:51:02.000000000 +0200
@@ -1303,7 +1303,7 @@ int osd_notify_callback(struct notifier_
 		osd_log_err("current vinfo NULL\n");
 		return -1;
 	}
-	osd_log_info("current vmode=%s, cmd: 0x%lx\n",
+	osd_log_info("osd current vmode=%s, cmd: 0x%lx\n",
 		vinfo->name, cmd);
 	switch (cmd) {
 #if 0
diff -Naurp linux/drivers/amlogic/display/vout/tv_vout.h linux-patch/drivers/amlogic/display/vout/tv_vout.h
--- linux/drivers/amlogic/display/vout/tv_vout.h	2018-06-27 06:13:58.000000000 +0300
+++ linux-patch/drivers/amlogic/display/vout/tv_vout.h	2018-11-30 09:51:02.000000000 +0200
@@ -147,6 +147,7 @@ static struct vmode_tvmode_tab_s mode_ta
 	{TVMODE_4K05K_200HZ_Y420, VMODE_4K05K_200HZ_Y420},
 	{TVMODE_4K05K_240HZ, VMODE_4K05K_240HZ},
 	{TVMODE_4K05K_240HZ_Y420, VMODE_4K05K_240HZ_Y420},
+	{TVMODE_NULL,VMODE_NULL},
 };
 
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
diff -Naurp linux/drivers/amlogic/display/vout/vout_serve.c linux-patch/drivers/amlogic/display/vout/vout_serve.c
--- linux/drivers/amlogic/display/vout/vout_serve.c	2018-11-30 09:45:44.000000000 +0200
+++ linux-patch/drivers/amlogic/display/vout/vout_serve.c	2018-11-30 09:51:02.000000000 +0200
@@ -392,7 +392,18 @@ static ssize_t vout_attr_vinfo_show(stru
 		info->sync_duration_num, info->sync_duration_den,
 		info->screen_real_width, info->screen_real_height,
 		info->video_clk, info->viu_color_fmt);
-	len += sprintf(buf+len, "hdr_info:\n"
+	len += sprintf(buf+len, "hdr info:\n"
+		"    hdr_support           0x%08x\n"
+		"    lumi_max              %d\n"
+		"    lumi_avg              %d\n"
+		"    lumi_min              %d\n"
+		"    sink_flag             %s\n\n",
+		info->hdr_info.hdr_support,
+		info->hdr_info.lumi_max,
+		info->hdr_info.lumi_avg,
+		info->hdr_info.lumi_min,
+		info->hdr_info.sink_flag ? "panel" : "hdmi out");
+	len += sprintf(buf+len, "hdr master display info:\n"
 		"    present_flag          %d\n"
 		"    features              0x%x\n"
 		"    primaries             0x%x, 0x%x\n"
diff -Naurp linux/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c linux-patch/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
--- linux/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c	2018-06-27 06:13:58.000000000 +0300
+++ linux-patch/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c	2018-11-30 09:51:02.000000000 +0200
@@ -880,9 +880,9 @@ static struct hdmi_format_para fmt_para_
 	.progress_mode = 1,
 	.scrambler_en = 0,
 	.tmds_clk_div40 = 0,
-	.tmds_clk = 594000,
+	.tmds_clk = 297000,
 	.timing = {
-		.pixel_freq = 594000,
+		.pixel_freq = 297000,
 		.h_freq = 112500,
 		.v_freq = 50000,
 		.vsync_polarity = 1,
@@ -942,10 +942,10 @@ static struct hdmi_format_para fmt_para_
 	.progress_mode = 1,
 	.scrambler_en = 0,
 	.tmds_clk_div40 = 0,
-	.tmds_clk = 594000,
+	.tmds_clk = 297000,
 	.timing = {
-		.pixel_freq = 594000,
-		.frac_freq = 593407,
+		.pixel_freq = 297000,
+		.frac_freq = 296703,
 		.h_freq = 135000,
 		.v_freq = 60000,
 		.vsync_polarity = 1,
@@ -1168,7 +1168,7 @@ static void hdmi_parse_attr(struct hdmi_
 	}
 	/* set default value */
 	if (i == sizeof(parse_cr_) / sizeof(struct parse_cr))
-		para->cr = COLORRANGE_FUL;
+		para->cr = COLORRANGE_LIM;
 }
 
 /*
@@ -1224,7 +1224,9 @@ struct hdmi_format_para *hdmi_get_fmt_na
 		case HDMI_3840x2160p60_64x27:
 			break;
 		default:
-			para = &fmt_para_non_hdmi_fmt;
+			/* fall back to something which is hdmi legal */
+			pr_info("YUV420 mode illegal at that resolution - setting YUV444");
+			para->cs = COLORSPACE_YUV444;
 			break;
 		}
 	}
diff -Naurp linux/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c linux-patch/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
--- linux/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c	2018-06-27 06:13:58.000000000 +0300
+++ linux-patch/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c	2018-11-30 09:51:02.000000000 +0200
@@ -155,6 +155,18 @@ static int Edid_find_name_block(unsigned
 		ret = 1;
 	return ret;
 }
+static int Edid_find_range_block(unsigned char *data)
+{
+	int ret = 0;
+	int i;
+	for (i = 0; i < 3; i++) {
+		if (data[i])
+			return ret;
+	}
+	if (data[3] == 0xfd)
+		ret = 1;
+	return ret;
+}
 
 static void Edid_ReceiverProductNameParse(struct rx_cap *pRxCap,
 	unsigned char *data)
@@ -1402,10 +1414,14 @@ static int hdmitx_edid_block_parse(struc
 				pRXCap->IEEEOUI = 0x000c03;
 			else
 				goto case_hf;
-			pRXCap->ColorDeepSupport =
-				(unsigned long)BlockBuf[offset+5];
-			pRXCap->Max_TMDS_Clock1 =
-				(unsigned long)BlockBuf[offset+6];
+			if (count > 5){
+				pRXCap->ColorDeepSupport =
+					(unsigned long)BlockBuf[offset+5];
+				pRXCap->Max_TMDS_Clock1 =
+					(unsigned long)BlockBuf[offset+6];
+			}
+			else
+				pRXCap->Max_TMDS_Clock1 = 0;
 			if (count > 7) {
 				tmp = BlockBuf[offset+7];
 				idx = offset + 8;
@@ -1436,7 +1452,7 @@ case_hf:
 			if ((BlockBuf[offset] == 0xd8) &&
 				(BlockBuf[offset+1] == 0x5d) &&
 				(BlockBuf[offset+2] == 0xc4))
-				pRXCap->HF_IEEEOUI = 0xd85dc4;
+				pRXCap->HF_IEEEOUI = 0xc45dd8;
 			pRXCap->Max_TMDS_Clock2 = BlockBuf[offset+4];
 			pRXCap->scdc_present =
 				!!(BlockBuf[offset+5] & (1 << 7));
@@ -1829,6 +1845,7 @@ int hdmitx_edid_parse(struct hdmitx_dev
 	unsigned char BlockCount;
 	unsigned char *EDID_buf;
 	int i, j, ret_val;
+	int maxPixelClock = 0;
 	int idx[4];
 	struct rx_cap *pRXCap = &(hdmitx_device->RXCap);
 	struct vinfo_s *info = NULL;
@@ -1878,6 +1895,9 @@ int hdmitx_edid_parse(struct hdmitx_dev
 		if (Edid_find_name_block(&EDID_buf[idx[i]]))
 			Edid_ReceiverProductNameParse(&hdmitx_device->RXCap,
 				&EDID_buf[idx[i]+5]);
+
+		if (Edid_find_range_block(&EDID_buf[idx[i]]))
+			maxPixelClock = EDID_buf[idx[i]+9];
 	}
 
 	Edid_ManufactureDateParse(&hdmitx_device->RXCap, &EDID_buf[16]);
@@ -2046,6 +2066,30 @@ int hdmitx_edid_parse(struct hdmitx_dev
 				info->hdr_info.hdr_support);
 		}
 	}
+	/* Set maxTMDSclock1 from range block if it doesn't seem to be set right */
+	if (pRXCap->Max_TMDS_Clock1 < 15){
+		hdmi_print(IMP, EDID "Setting maxTMDSclock1 from range block\n");
+		pRXCap->Max_TMDS_Clock1 = maxPixelClock * 2;
+	}
+	/* Make sure we have a usable maxTMDSclock1 */
+	if (pRXCap->Max_TMDS_Clock1 < 15){
+		pRXCap->Max_TMDS_Clock1 = 35;
+		hdmi_print(IMP, EDID "No Valid maxTMDSclock1 Setting to 175Mhz\n");
+	}
+	/* If we have a high clock but no HF-VSDB it's probably HDMI 2, so fake a HF-VSDB */
+	if (maxPixelClock > 34 && ! pRXCap->Max_TMDS_Clock2 && ! pRXCap->HF_IEEEOUI){
+		hdmi_print(IMP, EDID "High clock, no HF-VSDB block, Is it missing?\n");
+		hdmi_print(IMP, EDID "Faking HF-VSDB block\n");
+		pRXCap->HF_IEEEOUI = 0xd85dc4;
+		pRXCap->Max_TMDS_Clock2 = maxPixelClock * 2;
+		pRXCap->scdc_present = 1;
+		pRXCap->scdc_rr_capable = 0;
+		pRXCap->lte_340mcsc_scramble = 0;
+		pRXCap->dc_30bit_420 = 0;
+		pRXCap->dc_36bit_420 = 0;
+		pRXCap->dc_48bit_420 = 0;
+	}
+
 	return 0;
 
 }
@@ -2424,11 +2468,11 @@ int hdmitx_edid_dump(struct hdmitx_dev *
 		"Manufacture Year: %d\n", pRXCap->manufacture_year+1990);
 
 	pos += snprintf(buffer+pos, buffer_len-pos,
-		"Physcial size(cm): %d x %d\n",
+		"Physical size(cm): %d x %d\n",
 		pRXCap->physcial_weight, pRXCap->physcial_height);
 
 	pos += snprintf(buffer+pos, buffer_len-pos,
-		"EDID Verison: %d.%d\n",
+		"EDID Version: %d.%d\n",
 		pRXCap->edid_version, pRXCap->edid_revision);
 
 	pos += snprintf(buffer+pos, buffer_len-pos,
@@ -2444,11 +2488,13 @@ int hdmitx_edid_dump(struct hdmitx_dev *
 		hdmitx_device->hdmi_info.vsdb_phy_addr.d);
 
 	pos += snprintf(buffer+pos, buffer_len-pos,
-		"native Mode %x, VIC (native %d):\n",
-		pRXCap->native_Mode, pRXCap->native_VIC);
+		"YCC support 0x%02x, VIC (native %d):\n",
+		(pRXCap->native_Mode & 0x30) >> 4, pRXCap->native_VIC);
 
 	pos += snprintf(buffer+pos, buffer_len-pos,
-		"ColorDeepSupport %x\n", pRXCap->ColorDeepSupport);
+		"ColorDeepSupport 0x%02x 10/12/16/Y444 %d/%d/%d/%d\n",
+		pRXCap->ColorDeepSupport, pRXCap->dc_30bit, pRXCap->dc_36bit,
+		pRXCap->dc_48bit, pRXCap->dc_y444);
 
 	for (i = 0 ; i < pRXCap->VIC_count ; i++) {
 		pos += snprintf(buffer+pos, buffer_len-pos, "%d ",
@@ -2459,19 +2505,19 @@ int hdmitx_edid_dump(struct hdmitx_dev *
 		"Audio {format, channel, freq, cce}\n");
 	for (i = 0; i < pRXCap->AUD_count; i++) {
 		pos += snprintf(buffer+pos, buffer_len-pos,
-			"{%d, %d, %x, %x}\n",
+			"{%d, %d, 0x%02x, 0x%02x}\n",
 			pRXCap->RxAudioCap[i].audio_format_code,
 			pRXCap->RxAudioCap[i].channel_num_max,
 			pRXCap->RxAudioCap[i].freq_cc,
 			pRXCap->RxAudioCap[i].cc3);
 	}
 	pos += snprintf(buffer+pos, buffer_len-pos,
-		"Speaker Allocation: %x\n", pRXCap->RxSpeakerAllocation);
+		"Speaker Allocation: 0x%02x\n", pRXCap->RxSpeakerAllocation);
 	pos += snprintf(buffer+pos, buffer_len-pos, "Vendor: 0x%x\n",
 		pRXCap->IEEEOUI);
 
 	pos += snprintf(buffer+pos, buffer_len-pos,
-		"MaxTMDSClock1 %d MHz\n", pRXCap->Max_TMDS_Clock1 * 5);
+		"MaxTMDSClock1 %d MHz%s\n", pRXCap->Max_TMDS_Clock1 * 5, pRXCap->Max_TMDS_Clock1 == 1 ? " or less" : "");
 
 	if (pRXCap->HF_IEEEOUI) {
 		pos += snprintf(buffer+pos, buffer_len-pos, "Vendor2: 0x%x\n",
diff -Naurp linux/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c linux-patch/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
--- linux/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c	2018-06-27 06:13:58.000000000 +0300
+++ linux-patch/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c	2018-11-30 09:51:02.000000000 +0200
@@ -64,6 +64,8 @@
 #include <linux/amlogic/hdmi_tx/hdmi_config.h>
 #include <linux/i2c.h>
 #include "hw/tvenc_conf.h"
+#include "hw/hdmi_tx_reg.h"
+#include "hw/mach_reg.h"
 #ifdef CONFIG_INSTABOOT
 #include <linux/amlogic/instaboot/instaboot.h>
 #endif
@@ -518,6 +520,13 @@ static int set_disp_mode_auto(void)
 	struct hdmi_format_para *para = NULL;
 	unsigned char mode[32];
 	enum hdmi_vic vic = HDMI_Unkown;
+	enum hdmi_color_depth stream_cur_cd;
+	char* pix_fmt[] = {"RGB","YUV422","YUV444","YUV420"};
+	char* eotf[] = {"SDR","HDR","HDR10","HLG"};
+	char* range[] = {"default","limited","full"};
+	char* colour_str[] = {"default", "SMPTE-C", "bt709", "xvYCC601","xvYCC709",
+		"sYCC601","opYCC601","opRGB","bt2020c","bt2020nc","P3 D65","P3 theater"};
+	
 	/* vic_ready got from IP */
 	enum hdmi_vic vic_ready = hdev->HWOp.GetState(
 		hdev, STAT_VIDEO_VIC, 0);
@@ -526,11 +535,19 @@ static int set_disp_mode_auto(void)
 
 	/* get current vinfo */
 	info = hdmi_get_current_vinfo();
-	hdmi_print(IMP, VID "get current mode: %s\n",
+	hdmi_print(IMP, VID "auto - get current mode: %s\n",
 		info ? info->name : "null");
 	if (info == NULL)
 		return -1;
 
+	/* save colourdepth of the stream */
+	stream_cur_cd = hdev->para->cd;
+	pr_info("hdmitx: stream colourdepth was %d in para 0x%08x (%s)\n",stream_cur_cd * 2, hdev->para, hdev->para->name);
+	if (hdev->cur_video_param != NULL){
+		pr_info("hdmitx: display colourdepth was %d in cur_param 0x%08x (VIC: %d)\n",hdev->cur_video_param->color_depth * 2,
+			hdev->cur_video_param,  hdev->cur_video_param->VIC);
+	}
+
 	info->fresh_tx_hdr_pkt = hdmitx_set_drm_pkt;
 	info->fresh_tx_vsif_pkt = hdmitx_set_vsif_pkt;
 	info->dv_info = &hdev->RXCap.dv_info;
@@ -560,6 +577,7 @@ static int set_disp_mode_auto(void)
 		hdev->HWOp.CntlMisc(hdev, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
 		hdev->HWOp.CntlConfig(hdev, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
 		hdev->para = para = hdmi_get_fmt_name("invalid", fmt_attr);
+		para->cd = stream_cur_cd;
 		return -1;
 	} else {
 		memcpy(mode, info->name, strlen(info->name));
@@ -577,36 +595,58 @@ static int set_disp_mode_auto(void)
 			}
 		}
 	}
-	/* In the file hdmi_common/hdmi_parameters.c,
-	 * the data array all_fmt_paras[] treat 2160p60hz and 2160p60hz420
-	 * as two different modes, such Scrambler
-	 * So if node "attr" contains 420, need append 420 to mode.
-	 */
-	if (strstr(fmt_attr, "420")) {
-		if (!strstr(mode, "420"))
-			strncat(mode, "420", 3);
-	}
+
 	para = hdmi_get_fmt_name(mode, fmt_attr);
+	/* check display caps - warn but don't force - these can only be set by sysfs */
+	if (para->cs == COLORSPACE_YUV422 && !(hdev->RXCap.native_Mode && 0x10))
+		   pr_warn("Colourspace is set to Y422 but display does not support it");
+	/* only RGB is mandatory in HDMI1.4 */
+	if (para->cs == COLORSPACE_YUV444 && !(hdev->RXCap.native_Mode && 0x20))
+		   pr_warn("Colourspace is set to Y444 but display does not support it");
 	hdev->para = para;
+	pr_info("hdmitx: hdev->para now = para at 0x%08x\n",hdev->para);
+	/* going to use cur_video_param for the bitdepth we really want */
+	if (hdev->cur_video_param != NULL){
+		if (strstr(fmt_attr,"bit") != NULL){
+			hdev->cur_video_param->color_depth = para->cd;
+			pr_info("hdmitx: display colourdepth set by attr to %d in cur_param 0x%08x (VIC: %d)\n",hdev->cur_video_param->color_depth * 2,
+					hdev->cur_video_param,  hdev->cur_video_param->VIC);
+		} else {
+			if (stream_cur_cd == COLORDEPTH_24B)
+				hdev->cur_video_param->color_depth = COLORDEPTH_24B;
+			if (stream_cur_cd == COLORDEPTH_30B)
+				hdev->cur_video_param->color_depth = COLORDEPTH_30B;
+			pr_info("hdmitx: display colourdepth is %d in cur_param 0x%08x (VIC: %d)\n",hdev->cur_video_param->color_depth * 2,
+					hdev->cur_video_param,  hdev->cur_video_param->VIC);
+		}
+		if (hdev->cur_video_param->color_depth > COLORDEPTH_24B){
+			int dc_support = 0;
+			if (hdev->RXCap.ColorDeepSupport & 0x78 && hdev->para->cs != COLORSPACE_YUV420)
+				dc_support = 1;
+			else if ((hdev->RXCap.HF_IEEEOUI) &&
+					((hdev->RXCap.dc_30bit_420 && hdev->cur_video_param->color_depth == COLORDEPTH_30B) ||
+					 (hdev->RXCap.dc_36bit_420 && hdev->cur_video_param->color_depth == COLORDEPTH_36B) ||
+					 (hdev->RXCap.dc_48bit_420 && hdev->cur_video_param->color_depth == COLORDEPTH_48B)))
+				dc_support = 1;
+			if (! dc_support){
+				pr_warn("Bitdepth is set to %d bits but display does not support deep colour",
+						hdev->cur_video_param->color_depth * 2);
+				hdev->cur_video_param->color_depth = COLORDEPTH_24B;
+			}
+		}
+	}
+	/* only set full range if forced */
+	if (strstr(fmt_attr,"full") == NULL)
+		hdev->para->cr = COLORRANGE_LIM;
+
+	/* and recover the original bitstream bitdepth */
+	para->cd = stream_cur_cd;
+	pr_info("hdmitx: Stream colourdepth is %d in para 0x%08x (%s - VIC: %d)\n",stream_cur_cd * 2, hdev->para, hdev->para->name, hdev->para->vic);
 	/* msleep(500); */
 	vic = hdmitx_edid_get_VIC(hdev, mode, 1);
-	if (strncmp(info->name, "2160p30hz", strlen("2160p30hz")) == 0) {
-		vic = HDMI_4k2k_30;
-	} else if (strncmp(info->name, "2160p25hz",
-		strlen("2160p25hz")) == 0) {
-		vic = HDMI_4k2k_25;
-	} else if (strncmp(info->name, "2160p24hz",
-		strlen("2160p24hz")) == 0) {
-		vic = HDMI_4k2k_24;
-	} else if (strncmp(info->name, "smpte24hz",
-		strlen("smpte24hz")) == 0)
-		vic = HDMI_4k2k_smpte_24;
-	else {
-	/* nothing */
-	}
 	if (suspend_flag == 1)
 		vic_ready = HDMI_Unkown;
-	if ((vic_ready != HDMI_Unkown) && (vic_ready == vic)) {
+	if ((vic_ready != HDMI_Unkown) && (vic_ready == vic) && (strstr(fmt_attr,"now") == NULL)) {
 		hdmi_print(IMP, SYS "[%s] ALREADY init VIC = %d\n",
 			__func__, vic);
 		if (hdev->RXCap.IEEEOUI == 0) {
@@ -630,13 +670,18 @@ static int set_disp_mode_auto(void)
 	} else
 		hdmitx_pre_display_init();
 
+	/* now is one-shot but attrs are sticky */
+	if (strstr(fmt_attr,"now") != NULL){
+		memcpy(strstr(fmt_attr,"now"), " ", 3);
+	}
+
 	hdev->cur_VIC = HDMI_Unkown;
 /* if vic is HDMI_Unkown, hdmitx_set_display will disable HDMI */
 	ret = hdmitx_set_display(hdev, vic);
-	pr_info("%s %d %d\n", info->name, info->sync_duration_num,
+	hdmi_print(IMP, VID"vinfo: %s %d %d\n", info->name, info->sync_duration_num,
 		info->sync_duration_den);
 	recalc_vinfo_sync_duration(info, hdev->frac_rate_policy);
-	pr_info("%s %d %d\n", info->name, info->sync_duration_num,
+	hdmi_print(IMP, VID"vinfo recalc: %s %d %d\n", info->name, info->sync_duration_num,
 		info->sync_duration_den);
 	if (ret >= 0) {
 		hdev->HWOp.Cntl(hdev, HDMITX_AVMUTE_CNTL, AVMUTE_CLEAR);
@@ -663,8 +708,50 @@ static int set_disp_mode_auto(void)
 	hdmitx_set_audio(hdev, &(hdev->cur_audio_param), hdmi_ch);
 	hdev->output_blank_flag = 1;
 	hdev->ready = 1;
+	/* report hdmi video status */ 
+
+	hdmi_print(IMP, VID "VIC: %d (%d) %s\n",
+			(hdmitx_rd_reg(HDMITX_DWC_FC_AVIVID) > 0 ? hdmitx_rd_reg(HDMITX_DWC_FC_AVIVID) :
+			 hdmitx_rd_reg(HDMITX_DWC_FC_VSDPAYLOAD1)), hdev->cur_VIC, hdev->para->name);
+
+	hdmi_print(IMP, VID "Bit depth: %d-bit, Colour range RGB: %s, YCC: %s, Colourspace: %s\n",
+			(((hdmitx_rd_reg(HDMITX_DWC_TX_INVID0) & 0x6) >> 1) + 4 ) * 2,
+			range[(hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF2) & 0xc) >> 2],
+			range[((hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF3) & 4) >> 2) + 1],
+			pix_fmt[(hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF0) & 0x3)]);
+
+	if (((hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF1) & 0xc0) >> 6) < 0x3)
+		hdmi_print(IMP, VID "Colorimetry: %s\n",
+				colour_str[(hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF1) & 0xc0) >> 6]);
+	else
+		hdmi_print(IMP, VID "Colorimetry: %s\n",
+				colour_str[((hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF2) & 0x70) >> 4) + 3]);
+
+	if ((hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB00) & 3) == 0x02) {
+		hdmi_print(IMP, VID "HDR data: EOTF: %s\n", eotf[(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB00) & 7)]);
+		if (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB02) > 0x0) {
+			hdmi_print(IMP, VID "Master display colours:\nPrimary one 0.%04d,0.%04d, two 0.%04d,0.%04d, three 0.%04d,0.%04d\nWhite 0.%04d,0.%04d, Luminance max/min: %d,0.%03d\n",
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB02) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB03) << 8)) * 2 / 10,
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB04) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB05) << 8)) * 2 / 10,
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB06) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB07) << 8)) * 2 / 10,
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB08) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB09) << 8)) * 2 / 10,
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB10) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB11) << 8)) * 2 / 10,
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB12) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB13) << 8)) * 2 / 10,
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB14) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB15) << 8)) * 2 / 10,
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB16) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB17) << 8)) * 2 / 10,
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB18) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB19) << 8)) / 10000,
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB20) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB21) << 8)));
+			hdmi_print(IMP, VID "Max content luminance: %d, Max frame average luminance: %d\n",
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB22) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB23) << 8)) / 10000,
+					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB24) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB25) << 8)) / 10000);
+		}
+		else hdmi_print(IMP, VID "No master display info\n");
+	}		
+		hdmi_print(IMP, VID "PLL clock: 0x%08x, Vid clock div 0x%08x\n",
+				hd_read_reg(P_HHI_HDMI_PLL_CNTL),
+				hd_read_reg(P_HHI_VID_PLL_CLK_DIV));
 	return ret;
-}
+} /* set_disp_mode_auto */
 
 static unsigned char is_dispmode_valid_for_hdmi(void)
 {
@@ -706,9 +793,12 @@ static ssize_t store_attr(struct device
 	struct device_attribute *attr, const char *buf, size_t count)
 {
 	memcpy(fmt_attr, buf, sizeof(fmt_attr));
+	if (strstr(fmt_attr,"now"))
+			set_disp_mode_auto();
 	return count;
 }
 
+
 /*aud_mode attr*/
 static ssize_t show_aud_mode(struct device *dev,
 	struct device_attribute *attr, char *buf)
@@ -1181,15 +1271,24 @@ static ssize_t show_config(struct device
 	struct hdmitx_dev *hdev = &hdmitx_device;
 
 	pos += snprintf(buf+pos, PAGE_SIZE, "cur_VIC: %d\n", hdev->cur_VIC);
-	if (hdev->cur_video_param)
-		pos += snprintf(buf+pos, PAGE_SIZE,
-			"cur_video_param->VIC=%d\n",
-			hdev->cur_video_param->VIC);
-	if (hdev->para) {
-		pos += snprintf(buf+pos, PAGE_SIZE, "cd = %d\n",
-			hdev->para->cd);
-		pos += snprintf(buf+pos, PAGE_SIZE, "cs = %d\n",
-			hdev->para->cs);
+	if (hdev->para){
+		struct hdmi_format_para *para;
+		para = hdev->para;
+
+		pos += snprintf(buf+pos, PAGE_SIZE, "VIC: %d %s\n",
+				hdmitx_device.cur_VIC, para->name);
+		char* pix_fmt[] = {"RGB","YUV422","YUV444","YUV420"};
+		char* eotf[] = {"SDR","HDR","HDR10","HLG"};
+		char* range[] = {"default","limited","full"};
+		pos += snprintf(buf + pos, PAGE_SIZE, "Colour depth: %d-bit\nColourspace: %s\nColour range: %s\nEOTF: %s\nYCC colour range: %s\n",
+				(((hdmitx_rd_reg(HDMITX_DWC_TX_INVID0) & 0x6) >> 1) + 4 ) * 2,
+				pix_fmt[(hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF0) & 0x3)],
+				range[(hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF2) & 0xc) >> 2],
+				eotf[(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB00) & 7)],
+				range[((hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF3) & 0xc) >> 2) + 1]);
+		pos += snprintf(buf + pos, PAGE_SIZE, "PLL clock: 0x%08x, Vid clock div 0x%08x\n",
+				hd_read_reg(P_HHI_HDMI_PLL_CNTL),
+				hd_read_reg(P_HHI_VID_PLL_CLK_DIV));
 	}
 
 	switch (hdev->tx_aud_cfg) {
@@ -1343,23 +1442,32 @@ static ssize_t show_disp_cap(struct devi
 	const char *native_disp_mode =
 		hdmitx_edid_get_native_VIC(&hdmitx_device);
 	enum hdmi_vic vic;
+	struct hdmi_format_para *para = NULL;
 	if (hdmitx_device.tv_no_edid) {
 		pos += snprintf(buf+pos, PAGE_SIZE, "null edid\n");
 	} else {
 		for (i = 0; disp_mode_t[i]; i++) {
 			vic = hdmitx_edid_get_VIC(&hdmitx_device,
-				disp_mode_t[i], 0);
-		if (vic != HDMI_Unkown) {
-			pos += snprintf(buf+pos, PAGE_SIZE, "%s",
-				disp_mode_t[i]);
-			if (native_disp_mode && (strcmp(
-				native_disp_mode,
-				disp_mode_t[i]) == 0)) {
-				pos += snprintf(buf+pos, PAGE_SIZE,
-					"*\n");
-			} else
-			pos += snprintf(buf+pos, PAGE_SIZE, "\n");
-		}
+					disp_mode_t[i], 0);
+			if (vic != HDMI_Unkown) {
+				/* sanity check */
+				para = hdmi_get_fmt_paras(vic);
+				if (! hdmitx_device.RXCap.HF_IEEEOUI &&
+						para->tmds_clk > hdmitx_device.RXCap.Max_TMDS_Clock1 * 5000){
+					pr_warn("Mode %s (VIC %d) needs %dMHz clock, at 444,8-bit - more than %dMHz",
+							disp_mode_t[i], vic, para->tmds_clk / 1000, hdmitx_device.RXCap.Max_TMDS_Clock1 * 5);
+				}
+				pos += snprintf(buf+pos, PAGE_SIZE, "%s",
+						disp_mode_t[i]);
+				if (native_disp_mode && (strcmp(
+								native_disp_mode,
+								disp_mode_t[i]) == 0)) {
+					pos += snprintf(buf+pos, PAGE_SIZE,
+							"*\n");
+				} else
+					pos += snprintf(buf+pos, PAGE_SIZE, "\n");
+
+			}
 		}
 	}
 	return pos;
@@ -2281,6 +2389,22 @@ static int hdmitx_notify_callback_v(stru
 	if (get_cur_vout_index() != 1)
 		return 0;
 
+	/* get current vinfo */
+	info = hdmi_get_current_vinfo();
+	if (info == NULL) {
+		hdmi_print(ERR, VID "cann't get valid mode\n");
+		return -1;
+	}
+
+	if (cmd == VOUT_EVENT_MODE_CHANGE_PRE){
+		hdmi_print(IMP, VID"vinfo: %s %d %d\n", info->name, info->sync_duration_num,
+				info->sync_duration_den);
+		recalc_vinfo_sync_duration(info, hdmitx_device.frac_rate_policy);
+		hdmi_print(IMP, VID"vinfo recalc: %s %d %d\n", info->name, info->sync_duration_num,
+				info->sync_duration_den);
+		return 0;
+	}
+
 	if (cmd != VOUT_EVENT_MODE_CHANGE)
 		return 0;
 
@@ -2289,12 +2413,6 @@ static int hdmitx_notify_callback_v(stru
 	/* vic_ready got from IP */
 	vic_ready = hdmitx_device.HWOp.GetState(&hdmitx_device,
 		STAT_VIDEO_VIC, 0);
-	/* get current vinfo */
-	info = hdmi_get_current_vinfo();
-	if (info == NULL) {
-		hdmi_print(ERR, VID "cann't get valid mode\n");
-		return -1;
-	}
 
 	vic_now = hdmitx_edid_get_VIC(&hdmitx_device, info->name, 1);
 	if (hdmitx_device.vic_count == 0) {
diff -Naurp linux/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c linux-patch/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
--- linux/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c	2018-06-27 06:13:58.000000000 +0300
+++ linux-patch/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c	2018-11-30 09:51:02.000000000 +0200
@@ -627,10 +627,16 @@ int hdmitx_set_display(struct hdmitx_dev
 	}
 
 	param = hdmi_get_video_param(VideoCode);
-	hdev->cur_video_param = param;
+	hdmi_print(IMP, SYS "params found at 0x%08x\n", param);
+	/* recover the bitdepth set in hdmi_tx_main */
+	if (hdev->cur_video_param != NULL)
+		param->color_depth = hdev->cur_video_param->color_depth;
 	if (param) {
+		hdev->cur_video_param = param;
+	        hdmi_print(IMP, SYS "cur_param = param at 0x%08x colourdepth %d\n", hdev->cur_video_param, hdev->cur_video_param->color_depth * 2);
 		param->color = param->color_prefer;
-		if (hdmi_output_rgb || is_philips_2009(&hdev->RXCap)) {
+		if (hdmi_output_rgb || is_philips_2009(&hdev->RXCap) ||
+			hdev->para->cs == COLORSPACE_RGB444) {
 			param->color = COLORSPACE_RGB444;
 		} else {
 			/* HDMI CT 7-24 Pixel Encoding
@@ -638,17 +644,29 @@ int hdmitx_set_display(struct hdmitx_dev
 			 */
 			switch (hdev->RXCap.native_Mode & 0x30) {
 			case 0x20:/*bit5==1, then support YCBCR444 + RGB*/
-			case 0x30:
 				param->color = COLORSPACE_YUV444;
 				break;
 			case 0x10:/*bit4==1, then support YCBCR422 + RGB*/
 				param->color = COLORSPACE_YUV422;
 				break;
+			case 0x30:
+				param->color = hdev->para->cs;
+				break;
 			default:
 				param->color = COLORSPACE_RGB444;
 			}
-			/* For Y420 modes */
 			switch (VideoCode) {
+			/* Try to stop 50hz/60hz 10bit YUV444 from happening */
+			case HDMI_3840x2160p50_16x9:
+			case HDMI_3840x2160p60_16x9:
+			case HDMI_4096x2160p50_256x135:
+			case HDMI_4096x2160p60_256x135:
+				if (param->color_depth > COLORDEPTH_24B){
+					param->color = COLORSPACE_YUV422;
+					pr_info("Setting colourspace to YCC422 for %d-bit\n", ((int) param->color_depth) * 2);
+				}
+				break;
+			/* For Y420 modes */
 			case HDMI_3840x2160p50_16x9_Y420:
 			case HDMI_3840x2160p60_16x9_Y420:
 			case HDMI_4096x2160p50_256x135_Y420:
@@ -658,12 +676,36 @@ int hdmitx_set_display(struct hdmitx_dev
 			default:
 				break;
 			}
-			if (param->color == COLORSPACE_RGB444) {
-				hdev->para->cs = hdev->cur_video_param->color;
-				pr_info("hdmitx: rx edid only support RGB format\n");
+			hdmi_print(IMP, VID "pixel freq %d, tmds clock %d, MaxClock1 %d, HF_IEEEOUI 0x%06x, MaxClock2 %d\n",
+					hdev->para->tmds_clk, hdev->para->tmds_clk * ((int) param->color_depth) / 
+					((int) COLORDEPTH_24B) / (param->color == COLORSPACE_YUV420 ? 2 : 1),
+					hdev->RXCap.Max_TMDS_Clock1 * 5000,
+					hdev->RXCap.HF_IEEEOUI, hdev->RXCap.HF_IEEEOUI ? hdev->RXCap.Max_TMDS_Clock2 * 5000 : 0);
+			if (param->color == COLORSPACE_YUV444){
+				int max_tmds_clock = hdev->RXCap.Max_TMDS_Clock1 * 5000;
+				if (hdev->RXCap.HF_IEEEOUI)
+					max_tmds_clock = hdev->RXCap.Max_TMDS_Clock2 * 5000;
+				if (hdev->para->tmds_clk * ((int) param->color_depth) / ((int) COLORDEPTH_24B) >
+						max_tmds_clock){
+					/* set 422 mode if sink can handle it */
+					if (hdev->RXCap.native_Mode & 0x10){
+						param->color = COLORSPACE_YUV422;
+						pr_info("Setting colourspace to YCC422 for %d-bit\n", ((int) param->color_depth) * 2);
+					} else {
+						pr_info("No support for YCC422, setting 8-bit\n");
+						param->color_depth = COLORDEPTH_24B;
+					}
+				}
 			}
+		}
 
+/*		if (param->color == COLORSPACE_RGB444) {
+			hdev->cur_video_param->color = param->color;
+			hdmi_print(IMP, VID "hdmitx: rx edid only support RGB format\n");
 		}
+*/
+		hdev->para->cs = param->color;
+
 		if (hdev->HWOp.SetDispMode(hdev) >= 0) {
 			/* HDMI CT 7-33 DVI Sink, no HDMI VSDB nor any
 			 * other VSDB, No GB or DI expected
diff -Naurp linux/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c linux-patch/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c
--- linux/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c	2018-11-30 09:45:45.000000000 +0200
+++ linux-patch/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c	2018-11-30 09:51:02.000000000 +0200
@@ -1863,7 +1863,7 @@ static int hdmitx_set_dispmode(struct hd
 	case HDMI_4096x2160p50_256x135:
 	case HDMI_4096x2160p60_256x135:
 		if ((hdev->para->cs == COLORSPACE_YUV420)
-			&& (hdev->para->cd == COLORDEPTH_24B))
+			&& (hdev->cur_video_param->color_depth == COLORDEPTH_24B))
 			hdev->para->tmds_clk_div40 = 0;
 		else
 			hdev->para->tmds_clk_div40 = 1;
@@ -1874,7 +1874,7 @@ static int hdmitx_set_dispmode(struct hd
 	case HDMI_4096x2160p60_256x135_Y420:
 	case HDMI_3840x2160p50_64x27_Y420:
 	case HDMI_3840x2160p60_64x27_Y420:
-		if (hdev->para->cd == COLORDEPTH_24B)
+		if (hdev->cur_video_param->color_depth == COLORDEPTH_24B)
 			hdev->para->tmds_clk_div40 = 0;
 		else
 			hdev->para->tmds_clk_div40 = 1;
@@ -1886,7 +1886,7 @@ static int hdmitx_set_dispmode(struct hd
 	case HDMI_3840x2160p30_16x9:
 	case HDMI_3840x2160p30_64x27:
 		if ((hdev->para->cs == COLORSPACE_YUV422)
-			|| (hdev->para->cd == COLORDEPTH_24B))
+			|| (hdev->cur_video_param->color_depth == COLORDEPTH_24B))
 			hdev->para->tmds_clk_div40 = 0;
 		else
 			hdev->para->tmds_clk_div40 = 1;
@@ -1898,19 +1898,6 @@ static int hdmitx_set_dispmode(struct hd
 	set_tmds_clk_div40(hdev->para->tmds_clk_div40);
 	scdc_config(hdev);
 
-	if (color_depth_f == 24)
-		hdev->cur_video_param->color_depth = COLORDEPTH_24B;
-	else if (color_depth_f == 30)
-		hdev->cur_video_param->color_depth = COLORDEPTH_30B;
-	else if (color_depth_f == 36)
-		hdev->cur_video_param->color_depth = COLORDEPTH_36B;
-	else if (color_depth_f == 48)
-		hdev->cur_video_param->color_depth = COLORDEPTH_48B;
-	hdmi_print(INF, SYS "set mode VIC %d (cd%d,cs%d,pm%d,vd%d,%x)\n",
-		hdev->cur_video_param->VIC, color_depth_f, COLORSPACE_f,
-		power_mode, power_off_vdac_flag, serial_reg_val);
-	if (COLORSPACE_f != 0)
-		hdev->cur_video_param->color = COLORSPACE_f;
 	hdmitx_set_pll(hdev);
 	/*hdmitx_set_phy(hdev);*/
 	if (hdev->flag_3dfp)
@@ -2321,7 +2308,10 @@ static void set_aud_info_pkt(struct hdmi
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF0,
 			GET_OUTCHN_NO(hdev->aud_output_ch) - 1, 4, 3);
 	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 0, 0, 3); /* SF */
-	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 0, 4, 2); /* SS */
+	if (audio_param->channel_num < 2)
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 3, 4, 2); /* SS */
+	else
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 0, 4, 2); /* SS */
 	switch (audio_param->type) {
 	case CT_MAT:
 		hdmi_print(INF, AUD "Audio Type: MAT(MLP)\n");
@@ -3848,14 +3838,14 @@ static int hdmitx_hdmi_dvi_config(struct
 	} else {
 
 		/* set ycc indicator */
-		if (hdmi_output_rgb) {
+		/*if (hdmi_output_rgb) {
 			hdmitx_csc_config(TX_INPUT_COLOR_FORMAT,
 				COLORSPACE_RGB444, TX_COLOR_DEPTH);
 			hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 0, 3, 1);
 		} else if (hdev->para->cs == COLORSPACE_YUV420)
 			hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF0, 3, 0, 2);
 		else
-			hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF0, 2, 0, 2);
+			hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF0, 2, 0, 2);*/
 		/* set hdmi flag */
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 1, 3, 1);
 	}
@@ -4167,28 +4157,6 @@ void hdmitx_set_avi_colorimetry(struct h
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 1, 6, 2);
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF2, 0, 4, 3);
 		break;
-	case HDMI_3840x2160p24_16x9:
-	case HDMI_3840x2160p25_16x9:
-	case HDMI_3840x2160p30_16x9:
-	case HDMI_3840x2160p50_16x9:
-	case HDMI_3840x2160p60_16x9:
-	case HDMI_4096x2160p24_256x135:
-	case HDMI_4096x2160p25_256x135:
-	case HDMI_4096x2160p30_256x135:
-	case HDMI_4096x2160p50_256x135:
-	case HDMI_4096x2160p60_256x135:
-	case HDMI_3840x2160p24_64x27:
-	case HDMI_3840x2160p25_64x27:
-	case HDMI_3840x2160p30_64x27:
-	case HDMI_3840x2160p50_64x27:
-	case HDMI_3840x2160p60_64x27:
-		if (para->cd != COLORDEPTH_24B) {
-			/* C1C0 Extended Colorimetry 3 */
-			hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 3, 6, 2);
-			/* Extended Colorimetry EC2/1/0 0 */
-			hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF2, 6, 4, 3);
-		}
-		break;
 	default:
 		/* C1C0 709 */
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 2, 6, 2);
@@ -4572,14 +4540,17 @@ static void config_hdmi20_tx(enum hdmi_v
 	hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 0x8, 0, 4);
 
 	hdmitx_set_avi_colorimetry(para);
-	if (hdev->hdr_src_feature)
+	if (hdev->hdr_src_feature){
 		hdev->HWOp.CntlConfig(hdev, CONF_AVI_BT2020, SET_AVI_BT2020);
+		pr_info("hdmitx: hw set BT2020");
+	}
 
 	data32  = 0;
-	data32 |= (((0 == COLORRANGE_FUL) ? 1 : 0) << 2);
+	data32 |= (((hdev->para->cr == COLORRANGE_FUL) ? 1 : 0) << 2);
 	data32 |= (0 << 0);
 	hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF3,   data32);
 
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF2, hdev->para->cr + 1, 2, 2);
 	hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, (para->vic & HDMITX_VIC_MASK));
 
 	/* write Audio Infoframe packet configuration */
@@ -5008,7 +4979,7 @@ static void hdmitx_set_hw(struct hdmitx_
 
 	pr_info("%s[%d] set VIC = %d\n", __func__, __LINE__, para->vic);
 	config_hdmi20_tx(vic, hdev,
-			hdev->para->cd,
+			hdev->cur_video_param->color_depth,
 			TX_INPUT_COLOR_FORMAT,
 			hdev->para->cs);
 	return;
diff -Naurp linux/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c linux-patch/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c
--- linux/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c	2018-06-27 06:13:58.000000000 +0300
+++ linux-patch/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c	2018-11-30 09:51:02.000000000 +0200
@@ -61,7 +61,7 @@ static void set_gxb_hpll_clk_out(unsigne
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		if (frac_rate)
 			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4a05, 0, 16);
 		else
@@ -76,7 +76,7 @@ static void set_gxb_hpll_clk_out(unsigne
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		if (frac_rate)
 			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4800, 0, 16);
 		else
@@ -91,7 +91,7 @@ static void set_gxb_hpll_clk_out(unsigne
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		if (frac_rate)
 			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4b84, 0, 16);
 		else
@@ -106,7 +106,7 @@ static void set_gxb_hpll_clk_out(unsigne
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		if (frac_rate)
 			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4443, 0, 16);
 		else
@@ -120,7 +120,7 @@ static void set_gxb_hpll_clk_out(unsigne
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4300, 0, 16);
 		break;
 	case 3243240:
@@ -131,7 +131,7 @@ static void set_gxb_hpll_clk_out(unsigne
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4300, 0, 16);
 		if (frac_rate)
 			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4800, 0, 16);
@@ -147,7 +147,7 @@ static void set_gxb_hpll_clk_out(unsigne
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		if (frac_rate)
 			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4d03, 0, 16);
 		else
@@ -162,7 +162,7 @@ static void set_gxb_hpll_clk_out(unsigne
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		if (frac_rate)
 			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
 		else
@@ -189,7 +189,7 @@ static void set_gxtvbb_hpll_clk_out(unsi
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		break;
 	case 5405400:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000270);
@@ -203,7 +203,7 @@ static void set_gxtvbb_hpll_clk_out(unsi
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		break;
 	case 4455000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800025c);
@@ -217,7 +217,7 @@ static void set_gxtvbb_hpll_clk_out(unsi
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		break;
 	case 3712500:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800024d);
@@ -231,7 +231,7 @@ static void set_gxtvbb_hpll_clk_out(unsi
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		break;
 	case 3450000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000247);
@@ -241,7 +241,7 @@ static void set_gxtvbb_hpll_clk_out(unsi
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		break;
 	case 3243240:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000243);
@@ -254,7 +254,7 @@ static void set_gxtvbb_hpll_clk_out(unsi
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		break;
 	case 2970000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800023d);
@@ -268,7 +268,7 @@ static void set_gxtvbb_hpll_clk_out(unsi
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4e00, 0, 16);
 		break;
 	case 4324320:
@@ -284,7 +284,7 @@ static void set_gxtvbb_hpll_clk_out(unsi
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		pr_info("HPLL: 0x%08x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		break;
 	default:
 		pr_info("error hpll clk: %d\n", clk);
@@ -849,10 +849,15 @@ void hdmitx_set_clk(struct hdmitx_dev *h
 {
 	enum hdmi_vic vic = hdev->cur_VIC;
 	struct hdmi_format_para *para = NULL;
+	enum hdmi_color_depth cd;
+	if (hdev->cur_video_param->color_depth && hdev->cur_video_param->color_depth > 0)
+		cd = hdev->cur_video_param->color_depth;
+	else
+		cd = hdev->para->cd;
 
 	frac_rate = hdev->frac_rate_policy;
 	pr_info("hdmitx: set clk: VIC = %d  cd = %d  frac_rate = %d\n", vic,
-		hdev->para->cd, frac_rate);
+		cd, frac_rate);
 	para = hdmi_get_fmt_paras(vic);
 	if (para && (para->name) && likely_frac_rate_mode(para->name))
 		;
@@ -866,7 +871,7 @@ void hdmitx_set_clk(struct hdmitx_dev *h
 		return;
 	}
 	if (hdev->para->cs != COLORSPACE_YUV422)
-		hdmitx_set_clk_(vic, hdev->para->cd);
+		hdmitx_set_clk_(vic, cd);
 	else
 		hdmitx_set_clk_(vic, COLORDEPTH_24B);
 }
diff -Naurp linux/include/linux/amlogic/hdmi_tx/hdmi_info_global.h linux-patch/include/linux/amlogic/hdmi_tx/hdmi_info_global.h
--- linux/include/linux/amlogic/hdmi_tx/hdmi_info_global.h	2018-06-27 06:13:58.000000000 +0300
+++ linux-patch/include/linux/amlogic/hdmi_tx/hdmi_info_global.h	2018-11-30 09:51:02.000000000 +0200
@@ -69,6 +69,7 @@ enum hdmi_barinfo {
 
 enum hdmi_colorimetry {
 	CC_NO_DATA = 0, CC_ITU601, CC_ITU709, CC_XVYCC601, CC_XVYCC709,
+	CC_SYCC601, CC_OPYCC601, CC_OPRGB, CC_ITU2020c, CC_ITU2020,
 };
 
 enum hdmi_slacing {
