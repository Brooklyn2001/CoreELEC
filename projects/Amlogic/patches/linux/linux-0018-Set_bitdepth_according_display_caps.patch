From 4fe6c204da2e6bf3c086a00882d7b880dc06c489 Mon Sep 17 00:00:00 2001
From: Graham Horner <graham@hornercs.co.uk>
Date: Wed, 24 Oct 2018 11:10:10 +0100
Subject: [PATCH] Set bitdepth according to display caps, improve EDID parse
 and add to HDR meta dump

---
 drivers/amlogic/display/vout/vout_serve.c     | 11 ++++++++
 .../amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c    |  3 +++
 .../amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c    | 12 +++++----
 .../amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c   | 27 ++++++-------------
 4 files changed, 29 insertions(+), 24 deletions(-)

diff --git a/drivers/amlogic/display/vout/vout_serve.c b/drivers/amlogic/display/vout/vout_serve.c
index 6254ed99176..85bba1331af 100644
--- a/drivers/amlogic/display/vout/vout_serve.c
+++ b/drivers/amlogic/display/vout/vout_serve.c
@@ -392,6 +392,17 @@ static ssize_t vout_attr_vinfo_show(struct class *class,
 		info->sync_duration_num, info->sync_duration_den,
 		info->screen_real_width, info->screen_real_height,
 		info->video_clk, info->viu_color_fmt);
+	len += sprintf(buf+len, "hdr info:\n"
+		"    hdr_support           0x%08x\n"
+		"    lumi_max              %d\n"
+		"    lumi_avg              %d\n"
+		"    lumi_min              %d\n"
+		"    sink_flag             %s\n\n",
+		info->hdr_info.hdr_support,
+		info->hdr_info.lumi_max,
+		info->hdr_info.lumi_avg,
+		info->hdr_info.lumi_min,
+		info->hdr_info.sink_flag ? "panel" : "hdmi out");
 	len += sprintf(buf+len, "hdr master display info:\n"
 		"    present_flag          %d\n"
 		"    features              0x%x\n"
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
index 4e362e524f5..1993e602e16 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
@@ -1406,6 +1406,9 @@ static int hdmitx_edid_block_parse(struct hdmitx_dev *hdmitx_device,
 				(unsigned long)BlockBuf[offset+5];
 			pRXCap->Max_TMDS_Clock1 =
 				(unsigned long)BlockBuf[offset+6];
+			/* clock cannot be less than 75MHz */
+			if (pRXCap->Max_TMDS_Clock1 < 15)
+				pRXCap->Max_TMDS_Clock1 = 15;
 			if (count > 7) {
 				tmp = BlockBuf[offset+7];
 				idx = offset + 8;
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
index 2c5bf2791b8..c90d88c073a 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
@@ -615,14 +615,15 @@ static int set_disp_mode_auto(void)
 			pr_info("hdmitx: display colourdepth set by attr to %d in cur_param 0x%08x (VIC: %d)\n",hdev->cur_video_param->color_depth * 2,
 					hdev->cur_video_param,  hdev->cur_video_param->VIC);
 		} else {
-			if (stream_cur_cd == COLORDEPTH_24B)
-				hdev->cur_video_param->color_depth = COLORDEPTH_24B;
+			hdev->cur_video_param->color_depth = COLORDEPTH_30B;
 			pr_info("hdmitx: display colourdepth is %d in cur_param 0x%08x (VIC: %d)\n",hdev->cur_video_param->color_depth * 2,
 					hdev->cur_video_param,  hdev->cur_video_param->VIC);
 		}
-		if (hdev->cur_video_param->color_depth > COLORDEPTH_24B && !(hdev->RXCap.ColorDeepSupport & 0x78))
+		if (hdev->cur_video_param->color_depth > COLORDEPTH_24B && !(hdev->RXCap.ColorDeepSupport & 0x78)){
 			pr_warn("Bitdepth is set to %d bits but display does not support deep colour",
 				hdev->cur_video_param->color_depth * 2);
+			hdev->cur_video_param->color_depth = COLORDEPTH_24B;
+		}
 	}
 	/* only set full range if forced */
 	if (strstr(fmt_attr,"full") == NULL)
@@ -717,7 +718,7 @@ static int set_disp_mode_auto(void)
 				colour_str[((hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF2) & 0x70) >> 4) + 3]);
 
 	if ((hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB00) & 3) == 0x02) {
-		hdmi_print(IMP, VID "HDR data: EOTF: %s\n", eotf[(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB00) & 3)]);
+		hdmi_print(IMP, VID "HDR data: EOTF: %s\n", eotf[(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB00) & 7)]);
 		if (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB02) > 0x0) {
 			hdmi_print(IMP, VID "Master display colours:\nPrimary one 0.%04d,0.%04d, two 0.%04d,0.%04d, three 0.%04d,0.%04d\nWhite 0.%04d,0.%04d, Luminance max/min: %d,0.%03d\n",
 					(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB02) | (hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB03) << 8)) * 2 / 10,
@@ -1270,7 +1271,7 @@ static ssize_t show_config(struct device *dev,
 				(((hdmitx_rd_reg(HDMITX_DWC_TX_INVID0) & 0x6) >> 1) + 4 ) * 2,
 				pix_fmt[(hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF0) & 0x3)],
 				range[(hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF2) & 0xc) >> 2],
-				eotf[(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB00) & 3)],
+				eotf[(hdmitx_rd_reg(HDMITX_DWC_FC_DRM_PB00) & 7)],
 				range[((hdmitx_rd_reg(HDMITX_DWC_FC_AVICONF3) & 0xc) >> 2) + 1]);
 		pos += snprintf(buf + pos, PAGE_SIZE, "PLL clock: 0x%08x, Vid clock div 0x%08x\n",
 				hd_read_reg(P_HHI_HDMI_PLL_CNTL),
@@ -1439,6 +1440,7 @@ static ssize_t show_disp_cap(struct device *dev,
 				/* sanity check */
 				para = hdmi_get_fmt_paras(vic);
 				if (! hdmitx_device.RXCap.HF_IEEEOUI &&
+						hdmitx_device.RXCap.Max_TMDS_Clock1 >= 15 &&
 						para->tmds_clk > hdmitx_device.RXCap.Max_TMDS_Clock1 * 5000){
 					pr_info("Mode %s (VIC %d) needs %dMHz clock, more than %dMHz",
 							disp_mode_t[i], vic, para->tmds_clk / 1000, hdmitx_device.RXCap.Max_TMDS_Clock1 * 5);
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
index eb6ddd2ca13..bc7b10a29ad 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
@@ -668,7 +668,11 @@ int hdmitx_set_display(struct hdmitx_dev *hdev, enum hdmi_vic VideoCode)
 					hdev->para->tmds_clk, hdev->para->tmds_clk * ((int) param->color_depth) / ((int) COLORDEPTH_24B),
 					hdev->RXCap.Max_TMDS_Clock1 * 5000,
 					hdev->RXCap.HF_IEEEOUI);
-			if (param->color == COLORSPACE_YUV444 && param->color_depth > COLORDEPTH_24B){
+			if (param->color == COLORSPACE_YUV444 &&
+					hdev->para->tmds_clk * ((int) param->color_depth) / ((int) COLORDEPTH_24B) >
+					hdev->RXCap.Max_TMDS_Clock1 * 5000 &&
+					! hdev->RXCap.HF_IEEEOUI){
+
 				/* set 422 mode if sink can handle it */
 				if (hdev->RXCap.native_Mode & 0x10){
 					param->color = COLORSPACE_YUV422;
@@ -678,25 +682,10 @@ int hdmitx_set_display(struct hdmitx_dev *hdev, enum hdmi_vic VideoCode)
 					param->color_depth = COLORDEPTH_24B;
 				}
 			}
-		}
 
-		if (param->color == COLORSPACE_RGB444) {
-			if (param->color_depth > COLORDEPTH_24B){
-				if (! hdmi_output_rgb){
-					/* set 422 mode if sink can handle it */
-					if (hdev->RXCap.native_Mode & 0x10){
-						param->color = COLORSPACE_YUV422;
-						pr_info("Setting colourspace to YCC422 for %d-bit\n", ((int) param->color_depth) * 2);
-					} else if ((param->color_depth == COLORDEPTH_30B && ! hdev->RXCap.dc_30bit) ||
-							(param->color_depth == COLORDEPTH_36B && ! hdev->RXCap.dc_36bit)) {
-						pr_info("No support for RGB deep colour, setting 8-bit\n");
-						param->color = COLORDEPTH_24B;
-					} else
-						pr_info("Colourdepth for RGB is %d-bit\n", ((int) param->color_depth) * 2);
-				} else {
-					pr_info("Setting 8-bit colourdepth for RGB\n");
-					param->color_depth = COLORDEPTH_24B;
-				}
+			if (param->color == COLORSPACE_RGB444) {
+				param->color = hdev->cur_video_param->color;
+				pr_info("hdmitx: rx edid only support RGB format\n");
 			}
 		}
 
